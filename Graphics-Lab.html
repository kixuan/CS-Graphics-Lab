<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>交互式图形系统</title>
    <style>
        body { font-family: Arial, sans-serif; display: flex; flex-direction: column; align-items: center; }
        #toolbar { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px; }
        #toolbar button { padding: 10px; font-size: 14px; cursor: pointer; }
        canvas { border: 1px solid black; }
    </style>
</head>
<body>
    <h1>交互式图形系统</h1>
    <div id="toolbar">
        <button onclick="setMode('select')">选择对象</button>
        <button onclick="setMode('point')">绘制点</button>
        <button onclick="setMode('line')">绘制直线</button>
        <button onclick="setMode('circle')">绘制圆</button>
        <button onclick="setMode('curve')">绘制曲线</button>
        <button onclick="setMode('text')">绘制文字</button>
        <button onclick="setMode('fill')">填充颜色</button>
        <button onclick="clipShape()">裁剪</button>
        <button onclick="applyTransform('translate')">平移</button>
        <button onclick="applyTransform('rotate')">旋转</button>
        <button onclick="applyTransform('scale')">缩放</button>
        <button onclick="setMode('fill')">种子填充</button>

        <button onclick="clearCanvas()">清空画布</button>
    </div>
    <canvas id="canvas" width="800" height="600"></canvas>
    <script src="main.js"></script>
</body>
</html>

<script>

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let currentMode = null; // 当前模式
let curvePoints = []; // 存储曲线控制点
let shapes = []; // 图形列表，每个图形形状带有类型和属性，例如：
/* 示例
shapes.push({
    type: 'circle',
    centerX: 100,
    centerY: 100,
    radius: 50,
    selected: false // 默认未选中
});
*/

canvas.addEventListener('mousedown', handleMouseDown);
canvas.addEventListener('mouseup', handleMouseUp);

function setMode(mode) {
    currentMode = mode;
}

function handleMouseDown(event) {
    const { offsetX: x, offsetY: y } = event;
    if (currentMode === 'fill') {
        const selectedShape = shapes.find(shape => shape.selected);
        if (!selectedShape) {
            alert("请先选择一个对象进行填充！");
            return;
        }

        const fillColor = prompt("请输入填充颜色（如 red 或 #FF0000）:");
        if (fillColor) {
            if (selectedShape.type === 'circle') {
                fillCircle(selectedShape, fillColor);
            } else {
                alert("该对象不支持填充操作！请选择圆形！");
            }
        }
    } else  if (currentMode === 'select') {
        // 进入选择模式：检测是否点击了某个图形
        let selectedShape = null;
        shapes.forEach(shape => {
            if (shape.type === 'point' && isNearPoint(x, y, shape.x, shape.y)) {
                selectedShape = shape;
            } else if (shape.type === 'line' && isNearLine(x, y, shape)) {
                selectedShape = shape;
            } else if (shape.type === 'circle' && isNearCircle(x, y, shape)) {
                selectedShape = shape;
            } else if (shape.type === 'text' && isNearText(x, y, shape)) {
                selectedShape = shape;
            }
        });

        // 如果选中图形，则标记
        if (selectedShape) {
            shapes.forEach(shape => (shape.selected = false)); // 清除之前的选中
            selectedShape.selected = true;
            console.log('选中图形：', selectedShape);
        } else {
            console.log('未选中任何图形');
        }

        redrawCanvas(); // 重绘画布以显示选中状态
    } else {
        // 进入绘图模式：处理点、直线、圆等的绘制
        if (currentMode === 'point') {
            drawPoint(x, y);
        } else if (currentMode === 'line') {
            startLine(x, y); // 保存直线起点
        } else if (currentMode === 'circle') {
            startCircle(x, y); // 保存圆心
        } else if (currentMode === 'curve') {
            curvePoints.push({ x, y });
            drawPoint(x, y); // 绘制控制点
            if (curvePoints.length === 4) {
                drawBezierCurve(curvePoints); // 绘制曲线
                curvePoints = []; // 清空控制点
            }
        } else if (currentMode === 'text') {
            const text = prompt("请输入要绘制的文字：");
            if (text) drawText(x, y, text);
        }
    }
}


// 判断是否靠近点
function isNearPoint(x, y, px, py) {
    const threshold = 5; // 检测阈值
    return Math.abs(x - px) <= threshold && Math.abs(y - py) <= threshold;
}


// 判断是否靠近直线
function isNearLine(x, y, line) {
    const { startX, startY, endX, endY } = line;
    const dist = pointToLineDistance(x, y, startX, startY, endX, endY);
    return dist <= 5; // 允许一定误差
}

function pointToLineDistance(px, py, x1, y1, x2, y2) {
    const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    const param = lenSq !== 0 ? dot / lenSq : -1;

    let xx, yy;
    if (param < 0) {
        xx = x1; yy = y1;
    } else if (param > 1) {
        xx = x2; yy = y2;
    } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
    }

    const dx = px - xx, dy = py - yy;
    return Math.sqrt(dx * dx + dy * dy);
}


// 判断是否靠近圆
function isNearCircle(x, y, circle) {
    const dx = x - circle.centerX;
    const dy = y - circle.centerY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    return Math.abs(dist - circle.radius) <= 5; // 检测是否在圆边附近
}


// 判断是否靠近文字（可根据文字宽高调整）
function isNearText(x, y, text) {
    ctx.font = '16px Arial';
    const textWidth = ctx.measureText(text.text).width;
    const textHeight = 16; // 假设字体大小为 16px
    return x >= text.x && x <= text.x + textWidth && y <= text.y && y >= text.y - textHeight;
}




function handleMouseUp(event) {
    const { offsetX: x, offsetY: y } = event;
    if (currentMode === 'line') finishLine(x, y);
    else if (currentMode === 'circle') finishCircle(x, y);
}

// 点
function drawPoint(x, y) {
    ctx.fillRect(x, y, 2, 2);
    shapes.push({ type: 'point', x, y });
}

// 直线
let startX, startY;
function startLine(x, y) {
    startX = x; startY = y;
}
function finishLine(x, y) {
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(x, y);
    ctx.stroke();
    shapes.push({ type: 'line', startX, startY, endX: x, endY: y });
}

// 圆
let circleX, circleY;
function startCircle(x, y) {
    circleX = x; circleY = y;
}
function finishCircle(x, y) {
    const radius = Math.sqrt((x - circleX) ** 2 + (y - circleY) ** 2);
    ctx.beginPath();
    ctx.arc(circleX, circleY, radius, 0, 2 * Math.PI);
    ctx.stroke();
    shapes.push({ type: 'circle', centerX: circleX, centerY: circleY, radius });
}

// 曲线
function drawBezierCurve(points) {
    if (points.length === 4) { // 三次贝塞尔曲线
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        ctx.bezierCurveTo(
            points[1].x, points[1].y,
            points[2].x, points[2].y,
            points[3].x, points[3].y
        );
        ctx.stroke();
        shapes.push({ type: 'bezier', points });
    } else if (points.length === 3) { // 二次贝塞尔曲线
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        ctx.quadraticCurveTo(
            points[1].x, points[1].y,
            points[2].x, points[2].y
        );
        ctx.stroke();
        shapes.push({ type: 'quadratic', points });
    }
}

// 文字
function drawText(x, y, text) {
    ctx.font = '16px Arial'; // 设置字体大小和样式
    ctx.fillText(text, x, y);
    shapes.push({ type: 'text', x, y, text });
}

// 几何变换
function applyTransform(type) {
    const selectedShape = shapes.find(shape => shape.selected);
    if (!selectedShape) {
        alert('请先选中一个对象！');
        return;
    }

    if (type === 'translate') {
        const dx = parseFloat(prompt('输入平移 x 距离:'));
        const dy = parseFloat(prompt('输入平移 y 距离:'));
        if (selectedShape.type === 'point') {
            selectedShape.x += dx;
            selectedShape.y += dy;
        } else if (selectedShape.type === 'line') {
            selectedShape.startX += dx;
            selectedShape.startY += dy;
            selectedShape.endX += dx;
            selectedShape.endY += dy;
        } else if (selectedShape.type === 'circle') {
            selectedShape.centerX += dx;
            selectedShape.centerY += dy;
        }
        redrawCanvas();
    } else if (type === 'rotate') {
        const angle = parseFloat(prompt('输入旋转角度（度数）:')) * (Math.PI / 180);
        if (selectedShape.type === 'line') {
            const centerX = (selectedShape.startX + selectedShape.endX) / 2;
            const centerY = (selectedShape.startY + selectedShape.endY) / 2;

            // 旋转起点和终点
            [selectedShape.startX, selectedShape.startY] = rotatePoint(
                selectedShape.startX, selectedShape.startY, centerX, centerY, angle
            );
            [selectedShape.endX, selectedShape.endY] = rotatePoint(
                selectedShape.endX, selectedShape.endY, centerX, centerY, angle
            );
        }
        redrawCanvas();
    } else if (type === 'scale') {
        const factor = parseFloat(prompt('输入缩放比例:'));
        if (selectedShape.type === 'line') {
            const centerX = (selectedShape.startX + selectedShape.endX) / 2;
            const centerY = (selectedShape.startY + selectedShape.endY) / 2;

            // 缩放起点和终点
            selectedShape.startX = centerX + (selectedShape.startX - centerX) * factor;
            selectedShape.startY = centerY + (selectedShape.startY - centerY) * factor;
            selectedShape.endX = centerX + (selectedShape.endX - centerX) * factor;
            selectedShape.endY = centerY + (selectedShape.endY - centerY) * factor;
        }
        redrawCanvas();
        }
}

//
function rotatePoint(x, y, cx, cy, angle) {
    const dx = x - cx, dy = y - cy;
    const newX = dx * Math.cos(angle) - dy * Math.sin(angle) + cx;
    const newY = dx * Math.sin(angle) + dy * Math.cos(angle) + cy;
    return [newX, newY];
}




// 重绘逻辑
function redrawCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    shapes.forEach(shape => {
        if (shape.selected) {
            ctx.strokeStyle = 'red'; // 选中对象显示红色
            ctx.lineWidth = 2;
        } else {
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
        }

        if (shape.type === 'point') {
            drawPoint(shape.x, shape.y);
        } else if (shape.type === 'line') {
            ctx.beginPath();
            ctx.moveTo(shape.startX, shape.startY);
            ctx.lineTo(shape.endX, shape.endY);
            ctx.stroke();
        } else if (shape.type === 'circle') {
            ctx.beginPath();
            ctx.arc(shape.centerX, shape.centerY, shape.radius, 0, 2 * Math.PI);
            ctx.stroke();
        } else if (shape.type === 'bezier' || shape.type === 'quadratic') {
            drawBezierCurve(shape.points);
        } else if (shape.type === 'text') {
            drawText(shape.x, shape.y, shape.text);
        }
    });
}



// 裁剪
function clipShape() {
    // 示例：Cohen-Sutherland 算法实现裁剪
    const clipXMin = parseFloat(prompt('裁剪窗口 xMin:'));
    const clipYMin = parseFloat(prompt('裁剪窗口 yMin:'));
    const clipXMax = parseFloat(prompt('裁剪窗口 xMax:'));
    const clipYMax = parseFloat(prompt('裁剪窗口 yMax:'));
    shapes = shapes.map(shape => {
        if (shape.type === 'line') {
            return cohenSutherland(shape, clipXMin, clipYMin, clipXMax, clipYMax);
        }
        return shape;
    });
    redrawCanvas();
}


// 种子填充
function fillSeed(x, y, fillColor) {
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const stack = [[x, y]];
    const targetColor = Array.from(ctx.getImageData(x, y, 1, 1).data);

    while (stack.length) {
        const [px, py] = stack.pop();
        const index = (py * canvas.width + px) * 4;

        if (matchColor(imageData.data, index, targetColor)) {
            setColor(imageData.data, index, fillColor);
            stack.push([px + 1, py], [px - 1, py], [px, py + 1], [px, py - 1]);
        }
    }
    ctx.putImageData(imageData, 0, 0);
}

function matchColor(data, index, color) {
    return data[index] === color[0] && data[index + 1] === color[1] && data[index + 2] === color[2];
}

function setColor(data, index, fillColor) {
    const rgb = hexToRgb(fillColor);
    data[index] = rgb.r;
    data[index + 1] = rgb.g;
    data[index + 2] = rgb.b;
    data[index + 3] = 255; // Alpha 通道
}

function hexToRgb(hex) {
    const bigint = parseInt(hex.slice(1), 16);
    return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
}

// 对对圆进行种子填充
function fillCircle(circle, fillColor) {
    const { centerX, centerY, radius } = circle;
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const stack = [[centerX, centerY]];
    const targetColor = Array.from(ctx.getImageData(centerX, centerY, 1, 1).data);

    while (stack.length) {
        const [px, py] = stack.pop();
        const index = (py * canvas.width + px) * 4;

        if (isInsideCircle(px, py, centerX, centerY, radius) && matchColor(imageData.data, index, targetColor)) {
            setColor(imageData.data, index, fillColor);
            stack.push([px + 1, py], [px - 1, py], [px, py + 1], [px, py - 1]);
        }
    }
    ctx.putImageData(imageData, 0, 0);
}

function isInsideCircle(x, y, cx, cy, r) {
    return Math.sqrt((x - cx) ** 2 + (y - cy) ** 2) <= r;
}



function clearCanvas() {
    shapes = []; // 清空图形列表
    ctx.clearRect(0, 0, canvas.width, canvas.height); // 清空画布
    console.log('画布已清空');
}

</script>